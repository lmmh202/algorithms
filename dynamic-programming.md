# Dynamic Programming (동적 계획법)

| 인덱스 접근 N=1인데 dp[2] 이런 인덱스에 접근하지 않도록 유의한다.

Dynamic Programming은 큰 문제를 작은 문제로 나누고, 한번 계산한 하위 문제의 결과값을 저장(Memoization/Tabulation)하여 중복 계산을 방지한다.

# DP를 적용하기 위한 2가지 전제 조건

1. Overlapping Subproblems(중복되는 하위 문제): 동일한 작은 문제들이 반복해서 나타나는 경우
2. Optimal Substructure(최적 부분 구조): 하위 문제들이 최적의 해를 결합하여 전체 문제의 해를 구할 수 있는 경우

# DP 접근방식 2가지

A. Top-down 방식 (메모이제이션 + 재귀)

가장 큰 문제에서 시작하여 하위 문제로 내려가며 결과를 저장하는 방식

- 장점: 점화식을 코드로 옮기기 직관적이다
- 단점: 재귀 깊이(Recursion Depth) 제한에 걸릴 수 있다.

B. Bottom-up 방식 (타뷸레이션 + 반복문)

작은 하위 문제부터 차례대로 표(Table)을 채워나가는 방식

- 장점: 재귀 호출 오버헤드가 없고 메모리 효율이 좋음. (일반적으로 알고리즘 테스트에서 선호됨)
- 단점: 문제의 범위를 미리 파악하고 초기값(Base Case)을 정확히 설정해야 함.

# 실전 DP 문제 해결 5단계 프로세스

1. DP 테이블 정의: dp[i]가 의미하는 바를 문장으로 정의합니다. (예: dp[i]는 i원까지의 최소 동전 개수)
2. 점화식 찾기: dp[i]를 구하기 위해 dp[i-1], dp[i-2] 등 이전 상태들을 어떻게 조합할지 결정합니다.
3. 초기값(Base Case) 설정: dp[0], dp[1] 등 가장 작은 단위의 해를 직접 입력합니다.
4. 반복문 방향 결정: 보통 작은 인덱스에서 큰 인덱스로 순회합니다.
5. 구현 및 최적화: 공간 복잡도를 줄일 수 있는지(변수 2개만 쓸 수 있는지 등) 검토합니다.
